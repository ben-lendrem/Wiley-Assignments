package com.app.dao;

import com.app.dto.Game;
import com.app.dto.Round;
import com.mysql.cj.jdbc.MysqlDataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;


@Repository
public class GameDAODBImpl implements GameDAO{

    private static final class GameMapper implements RowMapper<Game> {
        @Override
        public Game mapRow(ResultSet rs, int index) throws SQLException {
            Game g = new Game();
            g.setGameid(rs.getInt("gameid"));
            g.setAnswer(String.valueOf(rs.getInt("answer")));
            g.setNumGuesses(rs.getInt("numGuesses"));
            g.setFinished(rs.getBoolean("finished"));
            g.setWon(rs.getBoolean("won"));
            //check for null value on won
            if (rs.wasNull()) {
                g.setWon(null);
            }

            return g;
        }
    }

    private static final class RoundMapper implements RowMapper<Round> {
        @Override
        public Round mapRow(ResultSet rs, int index) throws SQLException {
            Round r = new Round();
            r.setRoundid(rs.getInt("roundid"));
            r.setGameid(rs.getInt("gameid"));
            r.setCurrentDateTime(rs.getTimestamp("date_and_time"));
            r.setGuess(rs.getInt("guess"));
            r.setResult(rs.getString("result"));

            return r;
        }

    }


    private JdbcTemplate jdbc;

    @Autowired
    public GameDAODBImpl(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }


    public Game NewGame(int ansIn)
    {
        //add game to the database, with subset of attributes, the other attributes are generated by default

        int x = jdbc.update("INSERT INTO game (answer,numGuesses,finished) VALUES (?,0,0)", ansIn);
        if (x == 1) {
            System.out.println("yep");
        }

        //retrieve game from database, and create game object with all attributes now with values

        List<Game> gList = jdbc.query("SELECT * FROM game WHERE answer=" + ansIn, new GameMapper());

        //if multiple games have been selected, choose the one that has is equal to a new game
        //if multiple games are equal to a new game, then return one of them? (Doesn't matter because new games with identical answers are the same at this point?)
        if (gList.size() < 1) {
            return null;
        } else {
            for (Game current : gList) {
                //find the first one that is in initial state and return it
                //numguesses, won, and finished are all 0
                if (!current.isFinished()             &&
                     current.isWon()         == null  &&
                     current.getNumGuesses() == 0     &&
                     Integer.parseInt(current.getAnswer()) == ansIn) {
                    return current;
                }
            }
        }

        //return null if no
        return null;
    }


    public Game RetrieveGame(int gameid) {
        List<Game> gList = jdbc.query("SELECT * FROM game WHERE gameid="+gameid, new GameMapper());
        if (gList.isEmpty()) {
            return null;
        } else {
            return gList.get(0);
        }
    }


    public Round AddRound(Round roundIn) {
        //comes in with gameid, guess, and answer
        //need to retrieve roundid value by taking size of RetrieveRoundsForGame, and adding 1
        int roundIdIn = RetrieveRoundsForGame(roundIn.getGameid()).size() + 1;
        roundIn.setRoundid(roundIdIn);
        jdbc.update("INSERT INTO round (roundid,gameid,guess,result) VALUES (?,?,?,?)",
                roundIdIn, roundIn.getGameid(), roundIn.getGuess(), roundIn.getResult());
        {
            Round dbRoundCopy = jdbc.query(
                    "SELECT * FROM round WHERE gameid=" + roundIn.getGameid()+
                    " AND roundid=" + roundIdIn, new RoundMapper())
                    .get(0);
            roundIn.setCurrentDateTime(dbRoundCopy.getCurrentDateTime());
        }

        return roundIn;
    }


    public void UpdateGameForNewRound(Game game, Round newRoundIn) {
        /*
        1. Increment numguesses by 1
        2. If the guess was correct, set finished to true and set won to true
        3. if guess was wrong, and max guesses has been reached, set finished to true and won to false
         */
        int newNumGuesses = game.getNumGuesses() + 1; //don't have to update game in memory as it's being dropped after this
        jdbc.update("UPDATE game SET numGuesses=? WHERE gameid=?", newNumGuesses, game.getGameid());
        char exactValChar = newRoundIn.getResult().charAt(2);
        int exactResult = Character.getNumericValue(exactValChar);
        if (exactResult == 4) {
            jdbc.update("UPDATE game SET finished=1, won=1 WHERE gameid=?", game.getGameid());
        } else {
            if (newNumGuesses == 10) {
                jdbc.update("UPDATE game SET finished=1, won=0 WHERE gameid=?", game.getGameid());
            }
        }

    }

    public List<Game> RetrieveAllGames() {
        return jdbc.query("SELECT * FROM game", new GameMapper());

    }


    public List<Round> RetrieveRoundsForGame(int gameid) {
        return jdbc.query("SELECT * FROM round WHERE gameid=" + gameid, new RoundMapper());

    }



}
